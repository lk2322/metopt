# Решение задачи линейного программирования (двухфазный симплекс)

Ф.И.О.: Владзиевский Евгений Дмитриевич

Поток:  МЕТОПТ 1.2 

## Краткое описание
Репозиторий содержит реализацию двухфазного симплекс-метода для решения задач линейного программирования общего вида (ограничения с <=, >=, =; целевая функция — max или min). Программа приводится к виду максимизации (если исходная задача — min, коэффициенты целевой функции инвертируются), затем выполняется:
- Фаза I: минимизация суммы искусственных переменных (проверка выполнимости). 
- Фаза II: симплекс-метод для исходной задачи без искусственных переменных.

Реализация находится в файле `main.py`. Входной файл формата простого текста `problem.txt` (см. пример).

## Алгоритм (псевдокод)
Ниже псевдокод двухфазного симплекс-метода, адаптированный под программу.

1. Парсинг входа: считать sense (max/min), коэффициенты c, матрицу A, вектор b, знаки ограничений (<=, >=, =).
2. Если sense == 'min': c_internal = -c, иначе c_internal = c.
3. Для каждой строки ограничения:
   - Если '<=': добавить slack-переменную +1 в соответствующем столбце.
   - Если '>=': добавить surplus-переменную (-1) и искусственную переменную (+1).
   - Если '=': добавить искусственную переменную (+1).
4. Построить начальную таблицу (табло) с дополнительными столбцами и базисом.
5. Фаза I:
   - Построить функцию цели = -sum(искусственных переменных).
   - Если какие-то искусственные переменные уже в базисе — корректируем функцию цели добавлением соответствующих строк.
   - Запустить симплекс: пока есть положительные коэффициенты в функции цели (правило выбора входящей переменной — наибольший положительный коэффициент), выбирать входящую и выходящую (по минимальному неотрицательному отношению), проводить pivot.
   - Если оптимум фазы I != 0 → задача несовместна (infeasible).
6. Удалить столбцы искусственных переменных и перейти к Фазе II:
   - Построить функцию цели из оригинальных коэффициентов (для внутреннего симплекса использовать c_internal), скорректировать её с учётом текущего базиса.
   - Запустить симплекс для оптимизации исходной цели.
7. Получить решение x (по исходным переменным) и вычислить значение целевой функции с использованием оригинальных коэффициентов (чтобы `min`-задача вернула положительное значение оптимума, как в исходной постановке).

Замечания по устойчивости и граничным случаям:
- Проверка на неограниченность (если для выбранной входящей переменной нет положительных коэффициентов в столбце).
- Обработка вырожденности и циклических случаев реализована косвенно через лимит итераций.

## Формат входного файла `problem.txt`
Первая строка: `max` или `min` затем коэффициенты целевой функции (через пробел).
Далее строки ограничений: коэффициенты (по числу переменных), знак (`<=`, `>=` или `=`) и правая часть.

Пример (тот же, что включён в репозиторий):

```
min 1 2 3 1
1 2 1 0 <= 7
0 1 1 1 = 6
1 0 0 1 >= 2
```

## Как развернуть и запустить
Требования: Python 3.8+ (macOS, Linux, Windows). 

1. Откройте терминал и перейдите в каталог проекта `lab1`:

```bash
cd /lab1
```

2. Запустите программу, передав имя файла с задачей:

```bash
python main.py problem.txt
```

Программа выведет результат в консоль и запишет файл `result.txt` в той же папке.


## Демонстрация работы (пример)
Вход (файл `problem.txt`):

```
min 1 2 3 1
1 2 1 0 <= 7
0 1 1 1 = 6
1 0 0 1 >= 2
```

Ожидаемый вывод (фрагмент `result.txt`):

```
Input LP:
sense: min, n = 4
Constraints:
[1.0, 2.0, 1.0, 0.0] <= 7.0
[0.0, 1.0, 1.0, 1.0] = 6.0
[1.0, 0.0, 0.0, 1.0] >= 2.0
c = [1.0, 2.0, 3.0, 1.0]

Result:
status: optimal
x = [0, 0, 0, 6]
Z = 6
```

Пояснение: решение даёт x4 = 6, другие переменные равны нулю, целевая функция минимальна и равна 6.



## Рефлективный вывод
Впечатления о работе над заданием:
- Что полезного: реализация двухфазного симплекса даёт практическое понимание, как вводятся искусственные и добавочные переменные, как формируется начальный базис; полезен также опыт корректного обращения с задачами на минимизацию (конвертация в максимизацию для внутреннего метода) и внимательное отношение к выводу значения целевой функции.
- Трудности: обработка знаков ограничений (`>=` требует surplus + искусственную переменную), корректное управление базисом при удалении искусственных переменных и корректировка функции цели на втором этапе. Также важна аккуратная работа с вырожденностью и численной устойчивостью (эпсилон для сравнения с нулём).
- Как преодолевалось: по этапам — сначала реализована конвертация и построение таблицы, затем фаза I, отладка на небольших тестах, затем фаза II; выявленные проблемы (например, неправильный знак Z в выводе) решались через хранение оригинальных коэффициентов и корректный пересчёт итоговой цели.